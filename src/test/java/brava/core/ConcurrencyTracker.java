package brava.core;

import com.google.common.base.Preconditions;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Unmodifiable;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * A helper class for testing concurrency.
 * <p>
 * Tracks how many different users are executing {@link #use(Object, Function)} at the same time.
 */
public final class ConcurrencyTracker {
    private final String        nickname;
    /**
     * The total number of times that {@link #use(Object, Function)} was invoked.
     */
    private final LongAdder     totalUsers   = new LongAdder();
    private final AtomicLong    maxUsers     = new AtomicLong();
    private final LongAdder     currentUsers = new LongAdder();
    private final AtomicBoolean trackerDone  = new AtomicBoolean();

    public ConcurrencyTracker(String nickname) {
        this.nickname = nickname;
    }

    public ConcurrencyTracker() {
        this.nickname = "ðŸ§µ";
    }

    private synchronized void userStart() {
        Preconditions.checkState(!trackerDone.get());
        totalUsers.increment();
        currentUsers.increment();
        maxUsers.accumulateAndGet(currentUsers.longValue(), Long::max);
    }

    private synchronized void userFinish() {
        Preconditions.checkState(!trackerDone.get());
        currentUsers.decrement();
    }

    private synchronized void trackerFinish() {
        Preconditions.checkState(currentUsers.longValue() == 0);
        trackerDone.set(false);
    }

    /**
     * Executes {@code code}, tracking how many threads are executing {@link #use(Object, Function)} at the same time.
     *
     * @param input the input to the {@link Function}
     * @param code  the {@link Function} that we're tracking
     * @return the result of the {@link Function}
     * @throws IllegalStateException if I've already been {@link #trackerFinish()}ed
     * @apiNote Different invocations of {@link #use(Object, Function)} can use different {@link Function}s - concurrency is based on the {@link #use(Object, Function)} method itself.
     */
    public <IN, OUT> OUT use(IN input, @NotNull Function<IN, OUT> code) {
        userStart();
        try {
            return code.apply(input);
        } finally {
            userFinish();
        }
    }

    /**
     * Executes some {@code code} using {@link IntStream#parallel()}, tracking the results using {@link #use(Object, Function)}.
     * <p>
     * After this, I will be {@link #trackerFinish()}ed.
     *
     * @param iterations the number of times you want the {@code code} to be executed
     * @param code       the {@link IntFunction} that will be executed in parallel
     * @return an unmodifiable {@link Stream#toList()} containing all of the results of {@code code}
     * @throws IllegalStateException    if this tracker has already been {@link #trackerFinish()}ed
     * @throws IllegalArgumentException if {@code iterations} is too small to actually run in parallel
     * @implNote The input to the {@code code} will be generated by {@link IntStream#range(int, int)}, up to {@code iterations} (exclusive).
     * This means that it <i>will</i> be unique for each execution of {@code code}, but it will <i>(probably) not</i> be in sequential order.
     * @implSpec This method must <b>NOT</b> be {@code synchronized} to work properly.
     */
    @Unmodifiable
    public <OUT> @NotNull List<OUT> runInParallel(int iterations, Function<Integer, OUT> code) {
        Preconditions.checkState(!trackerDone.get());
        Preconditions.checkArgument(
            iterations > 1,
            "for the results to be meaningful, you must use AT LEAST 2 iterations, otherwise it would be impossible for the code to run in parallel"
        );

        var results = IntStream.range(0, iterations)
            .parallel()
            .mapToObj(i -> use(i, code))
            .toList();

        trackerFinish();
        return results;
    }

    /**
     * @return a friendly name for debugging
     */
    public String nickname() {
        return nickname;
    }

    /**
     * @return the total number of times that {@link #use(Object, Function)} was invoked.
     */
    public synchronized long totalUsers() {
        trackerFinish();
        return totalUsers.longValue();
    }

    /**
     * @return the maximum number of concurrently-executing {@link #use(Object, Function)} calls.
     */
    public synchronized long maxUsers() {
        trackerFinish();
        return maxUsers.longValue();
    }

    @Contract(pure = true)
    @Override
    public @NotNull String toString() {
        return "%s users: total %s, max %s concurrently".formatted(nickname, totalUsers, maxUsers);
    }
}
